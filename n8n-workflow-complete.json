{
  "name": "WhatsApp House Bot",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "whatsapp",
        "responseMode": "onReceived",
        "options": {}
      },
      "id": "webhook",
      "name": "Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1.1,
      "position": [240, 300],
      "webhookId": "whatsapp"
    },
    {
      "parameters": {
        "jsCode": "const text = $input.item.json.body.text;\nconst group = $input.item.json.body.group;\nconst sender = $input.item.json.body.sender;\nconst timestamp = $input.item.json.body.timestamp;\n\nconst apiKey = 'YOUR_API_KEY';\nconst prompt = `Extract property information from this Indonesian property listing and return ONLY valid JSON with these exact fields: type (string), rooms (number), bathrooms (number), land_size (number in sqm), building_size (number in sqm), price (number), location (string), features (array of strings). If a field is not mentioned, use null. Message: ${text}`;\n\n// Call Gemini API\nconst response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent?key=${apiKey}`, {\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/json'\n  },\n  body: JSON.stringify({\n    contents: [{\n      parts: [{\n        text: prompt\n      }]\n    }]\n  })\n});\n\nconst data = await response.json();\n\n// Parse Gemini response\ntry {\n  const geminiText = data.candidates[0].content.parts[0].text;\n  const jsonMatch = geminiText.match(/\\{[\\s\\S]*\\}/);\n  const propertyData = jsonMatch ? JSON.parse(jsonMatch[0]) : {};\n  \n  return [{\n    json: {\n      date: new Date(timestamp * 1000).toISOString().split('T')[0],\n      time: new Date(timestamp * 1000).toTimeString().split(' ')[0],\n      sender: sender,\n      group: group,\n      raw_message: text,\n      type: propertyData.type || '',\n      rooms: propertyData.rooms || 0,\n      bathrooms: propertyData.bathrooms || 0,\n      land_size: propertyData.land_size || 0,\n      building_size: propertyData.building_size || 0,\n      price: propertyData.price || 0,\n      location: propertyData.location || '',\n      features: Array.isArray(propertyData.features) ? propertyData.features.join(', ') : ''\n    }\n  }];\n} catch (error) {\n  return [{\n    json: {\n      date: new Date(timestamp * 1000).toISOString().split('T')[0],\n      time: new Date(timestamp * 1000).toTimeString().split(' ')[0],\n      sender: sender,\n      group: group,\n      raw_message: text,\n      error: error.message,\n      gemini_response: JSON.stringify(data)\n    }\n  }];\n}"
      },
      "id": "parse-and-extract",
      "name": "Parse & Extract with Gemini",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [460, 300]
    },
    {
      "parameters": {
        "operation": "appendOrUpdate",
        "documentId": {
          "__rl": true,
          "value": "",
          "mode": "list",
          "cachedResultName": ""
        },
        "sheetName": {
          "__rl": true,
          "value": "Sheet1",
          "mode": "list",
          "cachedResultName": "Sheet1"
        },
        "columns": {
          "mappingMode": "autoMapInputData",
          "matchingColumns": [],
          "value": {}
        },
        "options": {}
      },
      "id": "google-sheets",
      "name": "Google Sheets",
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.4,
      "position": [1120, 300],
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "REPLACE_WITH_YOUR_CREDENTIAL_ID",
          "name": "Google Sheets account"
        }
      }
    }
  ],
  "connections": {
    "Webhook": {
      "main": [
        [
          {
            "node": "Parse & Extract with Gemini",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse & Extract with Gemini": {
      "main": [
        [
          {
            "node": "Google Sheets",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [],
  "triggerCount": 0,
  "updatedAt": "2026-01-04T10:00:00.000Z",
  "versionId": "1"
}
